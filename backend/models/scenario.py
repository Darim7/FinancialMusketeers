from typing import List, Dict, Union
import yaml

from exportable import Exportable
from investment import Investment
from event_series import EventSeries, Expense
from roth_optimizer import RothConvertOptimizer
from rmd import RMD
from user import User
from results import SimulationResults

class Scenario(Exportable):
    def __init__(
            self,
            name:str,
            is_married: bool,
            birth_yr: int,
            life_exp:Dict,
            ivmts: List[Investment],
            event_series: List[EventSeries],
            inflation_rate:Dict,
            spending_strat: List[Expense],
            aftertax_ann_contribution: int,
            expense_withdrawal_strat: List[Investment],
            rmd_strat: RMD,
            roth_optimizer:RothConvertOptimizer,
            roth_conversion_strat,
            financial_goal:int,
            state:str,
            pretax_ann_contribution:int,
            spouse_name:str="",
            spouse_birth_yr:int=0,
            spouse_life_exp:int=0,
            shared:List[User]=[]
        ):

        # Name
        self.name=name
        self.spouse_name=spouse_name

        # Marital Status
        self.is_married=is_married

        # Birth Years
        self.birth_yr=birth_yr
        self.spouse_birth_yr=spouse_birth_yr

        # Life Expectancy
        self.life_exp=life_exp
        self.spouse_life_exp=spouse_life_exp

        # Investments NOTE: Investment types are then generated by looping through this list.
        self.ivmts=ivmts

        # Event Series
        self.event_series=event_series
        
        # Inflation assumption
        self.inflation_rate=inflation_rate
        
        # After tax contribution limit (?)
        self.aftertax_ann_contribution=aftertax_ann_contribution
        
        # Spending Strategy
        self.spending_strat=spending_strat
        
        # Expense Withdrawal Strategy
        self.expense_withdrawal_strat=expense_withdrawal_strat
        
        # RMD Strategy
        self.rmd_strat=rmd_strat

        # RothConvOpt: Whether optimizer is used (Bool), start, end, strat (missing in optimizer)
        self.roth_optimizer=roth_optimizer

        # Financial Goal
        self.financial_goal=financial_goal

        # residence state
        self.state=state

        self.pretax_ann_contribution=pretax_ann_contribution

        # Operational Needed Data.
        self.shared=shared
        self.sim_results=[]
        
    def run(self, runs:int):
        pass
    
    def simulate(self):
        pass

    def to_dict(self) -> Dict:
        """Convert Scenario object to a dictionary matching YAML structure."""
        base = {
            "name": self.name,
            "maritalStatus": "couple" if self.is_married else "individual",
            "birthYears": self._get_birth_years(),
            "lifeExpectancy": self._get_life_expectancy_distributions(),
            "investmentTypes": self._get_investment_types(),
            "investments": [ivmt.to_dict() for ivmt in self.ivmts],
            "eventSeries": [es.to_dict() for es in self.event_series],
            "inflationAssumption": self._create_distribution("fixed", self.inflation_rate),
            "afterTaxContributionLimit": self.aftertax_ann_contribution,
            "spendingStrategy": [expense.name for expense in self.spending_strat],
            "expenseWithdrawalStrategy": [ivmt.id for ivmt in self.expense_withdrawal_strat],
            "RMDStrategy": self.rmd_strat.get_investment_ids(),
            "RothConversionOpt": self.roth_optimizer.enabled,
            "RothConversionStart": self.roth_optimizer.start,
            "RothConversionEnd": self.roth_optimizer.end,
            "RothConversionStrategy": self.roth_optimizer.get_investment_ids(),
            "financialGoal": self.financial_goal,
            "residenceState": self.state
        }
        
        # Add pretax contribution limit if exists
        if hasattr(self, 'pretax_ann_contribution'):
            base["pretaxContributionLimit"] = self.pretax_ann_contribution
            
        return base

    def export_yaml(self, filename: str):
        """Export scenario to YAML file with proper formatting."""
        data = self.to_dict()
        
        yaml_content = yaml.dump(
            data,
            sort_keys=False,
            default_flow_style=None,
            allow_unicode=True,
            width=120
        )
        
        # Add header comments
        header = """# file format for scenario import/export.  version: 2025-03-11
        # CSE416, Software Engineering, Scott D. Stoller.

        # a distribution is represented as a map with one of the following forms:
        # {type: fixed, value: <number>}
        # {type: normal, mean: <number>, stdev: <number>}
        # {type: uniform, lower: <number>, upper: <number>}
        # {type: GBM, mu: <number>, sigma: <number>}
        # percentages are represented by their decimal value, e.g., 4% is represented as 0.04.\n\n"""
        
        with open(filename, 'w') as f:
            f.write(header + yaml_content)

    def _get_birth_years(self) -> list:
        years = [self.birth_yr]
        if self.is_married:
            years.append(self.spouse_birth_yr)
        return years

    def _get_life_expectancy_distributions(self) -> list:
        distributions = [self._create_distribution("fixed", self.life_exp)]
        if self.is_married:
            distributions.append(self._create_distribution("fixed", self.spouse_life_exp))
        return distributions

    def _get_investment_types(self) -> list:
        seen = set()
        types = []
        for ivmt in self.ivmts:
            if ivmt.investment_type not in seen:
                types.append(ivmt.investment_type.to_dict())
                seen.add(ivmt.investment_type)
        return types

    @staticmethod
    def _create_distribution(dist_type: str, value: Union[float, dict]) -> dict:
        """Helper to create distribution dictionaries."""
        if isinstance(value, dict):
            return value
        return {"type": dist_type, "value": value}
