from typing import List, Dict, Self, Union
import yaml

from exportable import Exportable
from investment import Investment, AssetType
from event_series import EventSeries, Expense
from roth_optimizer import RothConvertOptimizer
from rmd import RMD
from results import SimulationResults

class Scenario(Exportable):
    def __init__(
            self,
            name: str,
            marital_status: str,  # "couple" or "individual"
            birth_years: List[int],
            life_expectancy: List[Dict],
            investment_types: List[AssetType],
            investments: List[Investment],
            event_series: List[EventSeries],
            inflation_assumption: Dict,
            after_tax_contribution_limit: int,
            spending_strategy: List[str],
            expense_withdrawal_strategy: List[str],
            rmd_strategy: List[str],
            roth_conversion_opt: bool,
            roth_conversion_start: int,
            roth_conversion_end: int,
            roth_conversion_strategy: List[str],
            financial_goal: int,
            residence_state: str,
            pretax_contribution_limit: int = 0,
            shared: List = None
        ):

        # Name
        self.name = name

        # Marital Status
        self.is_married = marital_status == 'couple'

        # Birth Years
        self._brith_years = birth_years
        self.birth_yr = birth_years[0]
        self.spouse_birth_yr = birth_years[1] if marital_status == 'couple' else -1

        # Life Expectancy
        self._life_expectancy = life_expectancy
        self.life_exp = life_expectancy[0]
        self.spouse_life_exp = life_expectancy[1] if marital_status == 'couple' else -1

        # Investments NOTE: Investment types are then generated by looping through this list.
        self.ivmt_type = investment_types
        self.ivmts = investments

        # Event Series
        self.event_series=event_series
        
        # Inflation assumption
        self.inflation_rate = inflation_assumption
        
        # After tax contribution limit (?)
        self.aftertax_ann_contribution = after_tax_contribution_limit
        
        # Spending Strategy
        self.spending_strat = spending_strategy
        
        # Expense Withdrawal Strategy
        self.expense_withdrawal_strat = expense_withdrawal_strategy
        
        # RMD Strategy
        self.rmd_strat = rmd_strategy

        # RothConvOpt: Whether optimizer is used (Bool), start, end, strat (missing in optimizer)
        self.roth_opt = roth_conversion_opt
        self.roth_strat = roth_conversion_strategy
        self.roth_start = roth_conversion_start
        self.roth_end = roth_conversion_end
        self.roth_optimizer = RothConvertOptimizer(roth_conversion_start, roth_conversion_end, roth_conversion_strategy) if roth_conversion_opt else None

        # Financial Goal
        self.financial_goal=financial_goal

        # residence state
        self.state = residence_state

        self.pretax_ann_contribution = pretax_contribution_limit

        # Operational Needed Data.
        self.shared=shared
        self.sim_results=[]
        
    def run(self, runs:int):
        pass
    
    def simulate(self):
        pass

    def to_dict(self) -> Dict:
        """Convert Scenario object to a dictionary matching YAML structure."""
        base = {
            "name": self.name,
            "maritalStatus": "couple" if self.is_married else "individual",
            "birthYears": self._brith_years,
            "lifeExpectancy": self._life_expectancy,
            "investmentTypes": [ivmt_type.to_dict() for ivmt_type in self.ivmt_type],
            "investments": [ivmt.to_dict() for ivmt in self.ivmts],
            "eventSeries": [es.to_dict() for es in self.event_series],
            "inflationAssumption": self.inflation_rate,
            "afterTaxContributionLimit": self.aftertax_ann_contribution,
            "spendingStrategy": self.spending_strat,
            "expenseWithdrawalStrategy": self.expense_withdrawal_strat,
            "RMDStrategy": self.rmd_strat,
            "RothConversionOpt": self.roth_opt,
            "RothConversionStart": self.roth_start,
            "RothConversionEnd": self.roth_end,
            "RothConversionStrategy": self.roth_strat,
            "financialGoal": self.financial_goal,
            "residenceState": self.state
        }
        
        # Add pretax contribution limit if exists
        if hasattr(self, 'pretax_ann_contribution'):
            base["pretaxContributionLimit"] = self.pretax_ann_contribution
            
        return base

    def export_yaml(self, filename: str):
        """Export scenario to YAML file with proper formatting."""
        data = self.to_dict()
        
        yaml_content = yaml.dump(
            data,
            sort_keys=False,
            default_flow_style=None,
            allow_unicode=True,
            indent=2,
            width=120
        )
        
        # Add header comments
        header = """# file format for scenario import/export.  version: 2025-03-11
        # CSE416, Software Engineering, Scott D. Stoller.

        # a distribution is represented as a map with one of the following forms:
        # {type: fixed, value: <number>}
        # {type: normal, mean: <number>, stdev: <number>}
        # {type: uniform, lower: <number>, upper: <number>}
        # {type: GBM, mu: <number>, sigma: <number>}
        # percentages are represented by their decimal value, e.g., 4% is represented as 0.04.\n\n"""
        
        with open(filename, 'x') as f:
            f.write(header + yaml_content)

    @classmethod
    def from_dict(cls, data: Dict) -> Self:
        """Factory method for creating from dictionary"""
        return cls(
            name=data['name'],
            marital_status=data['maritalStatus'],
            birth_years=data['birthYears'],
            life_expectancy=data['lifeExpectancy'],
            investment_types=[
                AssetType.from_dict(it)
                for it in data['investmentTypes']
            ],
            investments=[
                Investment.from_dict(iv) 
                for iv in data['investments']
            ],
            event_series=[
                EventSeries.from_dict(es) 
                for es in data['eventSeries']
            ],
            inflation_assumption=data['inflationAssumption'],
            after_tax_contribution_limit=data['afterTaxContributionLimit'],
            spending_strategy=data['spendingStrategy'],
            expense_withdrawal_strategy=data['expenseWithdrawalStrategy'],
            rmd_strategy=data['RMDStrategy'],
            roth_conversion_opt=data['RothConversionOpt'],
            roth_conversion_start=data['RothConversionStart'],
            roth_conversion_end=data['RothConversionEnd'],
            roth_conversion_strategy=data['RothConversionStrategy'],
            financial_goal=data['financialGoal'],
            residence_state=data['residenceState'],
            pretax_contribution_limit=data.get('pretaxContributionLimit', 0)
        )

    @classmethod
    def from_yaml(cls, filename: str) -> Self:
        """Create Scenario from YAML file"""
        with open(filename, 'r') as f:
            data = yaml.safe_load(f)
        return cls.from_dict(data)
    
if __name__ == '__main__':
    s = Scenario.from_yaml("./tests/python_scripts_test/scenario.yaml")
    s.export_yaml('test.yml')
