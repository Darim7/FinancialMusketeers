from typing import List, Dict, Self, Union, Optional
from bson import ObjectId
from datetime import date
import yaml
import logging

logger = logging.getLogger(__name__)

from models.exportable import Exportable
from models.investment import Investment, AssetType
from models.event_series import EventSeries, Expense
from models.roth_optimizer import RothConvertOptimizer
from models.rmd import RMD
from models.results import SimulationResults
from dbconn import SCENARIO_COLLECTION

class Scenario(Exportable):
    def __init__(
            self,
            name: str,
            marital_status: str,  # "couple" or "individual"
            birth_years: List[int], 
            life_expectancy: List[Dict],
            investment_types: List[AssetType],
            investments: List[Investment],
            event_series: List[EventSeries],
            inflation_assumption: Dict,
            after_tax_contribution_limit: int,
            spending_strategy: List[str],
            expense_withdrawal_strategy: List[str],
            rmd_strategy: List[str],
            roth_conversion_opt: bool,
            roth_conversion_start: int,
            roth_conversion_end: int,
            roth_conversion_strategy: List[str],
            financial_goal: int,
            residence_state: str,
            shared: List = [],
        ):

        # Name
        self.name = name

        # Marital Status
        self.is_married = marital_status == 'couple'

        # Birth Years
        self._birth_years = birth_years  
        self.birth_yr = birth_years[0]
        self.spouse_birth_yr = birth_years[1] if marital_status == 'couple' else -1

        # Life Expectancy
        self._life_expectancy = life_expectancy
        self.life_exp = life_expectancy[0]
        self.spouse_life_exp = life_expectancy[1] if marital_status == 'couple' else -1

        # Investments NOTE: Investment types are then generated by looping through this list.
        self.ivmt_types = investment_types
        self.ivmts = investments

        # Event Series
        self.event_series=event_series
        
        # Inflation assumption
        self.inflation_rate = inflation_assumption
        
        # After tax contribution limit (?)
        self.aftertax_ann_contribution = after_tax_contribution_limit
        
        # Spending Strategy
        self.spending_strat = spending_strategy
        
        # Expense Withdrawal Strategy
        self.expense_withdrawal_strat = expense_withdrawal_strategy
        
        # RMD Strategy
        self.rmd_strat = rmd_strategy

        # RothConvOpt: Whether optimizer is used (Bool), start, end, strat (missing in optimizer)
        self.roth_opt = roth_conversion_opt
        self.roth_strat = roth_conversion_strategy
        self.roth_start = roth_conversion_start
        self.roth_end = roth_conversion_end
        self.roth_optimizer = RothConvertOptimizer(roth_conversion_start, roth_conversion_end, roth_conversion_strategy) if roth_conversion_opt else None

        # Financial Goal
        self.financial_goal=financial_goal

        # residence state
        self.state = residence_state


        # Operational Needed Data.
        self.shared=shared
        self.sim_results=[]
   
    # Getter methods
    def get_name(self) -> str:
        return self.name

    def get_marital_status(self) -> str:
        return "couple" if self.is_married else "individual"

    def get_birth_years(self) -> List[int]:
        return self._birth_years

    def get_life_expectancy(self) -> List[Dict]:
        return self._life_expectancy

    def get_investment_types(self) -> List[AssetType]:
        return self.ivmt_types

    def get_investments(self) -> List[Investment]:
        return self.ivmts

    def get_event_series(self) -> List[EventSeries]:
        return self.event_series

    def get_inflation_assumption(self) -> Dict:
        return self.inflation_rate

    def get_after_tax_contribution_limit(self) -> int:
        return self.aftertax_ann_contribution

    def get_spending_strategy(self) -> List[str]:
        return self.spending_strat

    def get_expense_withdrawal_strategy(self) -> List[str]:
        return self.expense_withdrawal_strat

    def get_rmd_strategy(self) -> List[str]:
        return self.rmd_strat

    def is_roth_conversion_enabled(self) -> bool:
        return self.roth_opt

    def get_roth_conversion_start(self) -> int:
        return self.roth_start

    def get_roth_conversion_end(self) -> int:
        return self.roth_end

    def get_roth_conversion_strategy(self) -> List[str]:
        return self.roth_strat

    def get_financial_goal(self) -> int:
        return self.financial_goal

    def get_residence_state(self) -> str:
        return self.state


    def get_shared_data(self) -> List:
        return self.shared

    def get_simulation_results(self) -> List:
        return self.sim_results
    
    def run(self, runs:int):
        pass
    
    def simulate(self):
        pass

    # PT: Can you write me a method that converts this class to a dictionary for
    # creating yaml file?
    def to_dict(self) -> Dict:
        """Convert Scenario object to a dictionary matching YAML structure."""
        base = {
            "name": self.name,
            "maritalStatus": "couple" if self.is_married else "individual",
            "birthYears": self._birth_years,
            "lifeExpectancy": self._life_expectancy,
            "investmentTypes": [ivmt_type.to_dict() for ivmt_type in self.ivmt_types],
            "investments": [ivmt.to_dict() for ivmt in self.ivmts],
            "eventSeries": [es.to_dict() for es in self.event_series],
            "inflationAssumption": self.inflation_rate,
            "afterTaxContributionLimit": self.aftertax_ann_contribution,
            "spendingStrategy": self.spending_strat,
            "expenseWithdrawalStrategy": self.expense_withdrawal_strat,
            "RMDStrategy": self.rmd_strat,
            "RothConversionOpt": self.roth_opt,
            "RothConversionStart": self.roth_start,
            "RothConversionEnd": self.roth_end,
            "RothConversionStrategy": self.roth_strat,
            "financialGoal": self.financial_goal,
            "residenceState": self.state
        }
        
        # Add pretax contribution limit if exists
        # if hasattr(self, 'pretax_ann_contribution'):
        #     base["pretaxContributionLimit"] = self.pretax_ann_contribution


        return base
    
    def save_to_db(self) -> ObjectId:
        """Save the scenario to the database and return the ObjectId."""
        return SCENARIO_COLLECTION.insert_one(self.to_dict()).inserted_id

    def export_yaml(self, filename: str):
        """Export scenario to YAML file with proper formatting."""
        data = self.to_dict()
        
        yaml_content = yaml.dump(
            data,
            sort_keys=False,
            default_flow_style=None,
            allow_unicode=True,
            indent=2,
            width=120
        )
        
        # Add header comments
        header = "# file format for scenario import/export.\n# version: 2025-03-11\n# CSE416, Software Engineering, Scott D. Stoller.\n# a distribution is represented as a map with one of the following forms:\n# {type: fixed, value: <number>}\n# {type: normal, mean: <number>, stdev: <number>}\n# {type: uniform, lower: <number>, upper: <number>}\n# {type: GBM, mu: <number>, sigma: <number>}\n# percentages are represented by their decimal value, e.g., 4% is represented as 0.04.\n\n"
        
        with open(filename, 'x') as f:
            f.write(header + yaml_content)

    # PT: Can you write me the from_dict() method that reads a dictionary that is
    # read from a yaml file and create an instance of this class?
    @classmethod
    def from_dict(cls, data: Dict) -> Self:
        """Factory method for creating from dictionary"""
        # logger.info("what is Roth Conversion Start : %s",data['RothConversionStart'])
        # logger.info("what is Roth Conversion End : %s",data['RothConversionEnd'])

        return cls(
            name=data['name'],
            marital_status=data['maritalStatus'],
            birth_years=data['birthYears'],
            life_expectancy=data['lifeExpectancy'],
            investment_types=[
                AssetType.from_dict(it)
                for it in data['investmentTypes']
            ],
            investments=[
                Investment.from_dict(iv) 
                for iv in data['investments']
            ],
            event_series=[
                EventSeries.from_dict(es) 
                for es in data['eventSeries']
            ],
            inflation_assumption=data['inflationAssumption'],
            after_tax_contribution_limit=data['afterTaxContributionLimit'],
            spending_strategy=data['spendingStrategy'],
            expense_withdrawal_strategy=data['expenseWithdrawalStrategy'],
            rmd_strategy=data['RMDStrategy'],
            roth_conversion_opt=data['RothConversionOpt'],
            roth_conversion_start=data['RothConversionStart'],
            roth_conversion_end=data['RothConversionEnd'],
            roth_conversion_strategy=data['RothConversionStrategy'],
            financial_goal=data['financialGoal'],
            residence_state=data['residenceState'],
        )

    @classmethod
    def from_yaml(cls, filename: str) -> Self:
        """Create Scenario from YAML file"""
        with open(filename, 'r') as f:
            data = yaml.safe_load(f)
        return cls.from_dict(data)


if __name__ == '__main__':
    print("Running test scenario")
    # s = Scenario.from_yaml("./tests/python_scripts_test/scenario.yaml")
    # s.export_yaml('test.yaml')
    # objid = s.save_to_db()
    # print(objid)
    # SCENARIO_COLLECTION.delete_one({"_id": objid})
    # print("Deleted scenario from db")
